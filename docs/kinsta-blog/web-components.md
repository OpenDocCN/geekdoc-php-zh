# 2022 年 Web 组件的完整介绍

> 原文：<https://kinsta.com/blog/web-components/>

我们都有我们不想做的项目。代码变得难以管理，范围不断发展，快速修复应用于其他修复之上，结构在大量代码的重压下崩溃。编码可能是一件麻烦的事情。

项目受益于使用具有单一职责的简单、独立的模块。模块化代码是封装的，所以不太需要担心实现。只要你知道当给定一组输入时，一个模块将输出什么，你就不一定需要理解*它是如何实现这个目标的。*

将模块化概念应用到单一的[编程语言](https://kinsta.com/blog/best-programming-language-to-learn/)很简单，但是 web 开发需要多种技术的混合。[浏览器](https://kinsta.com/browser-market-share/)解析 [HTML](https://kinsta.com/blog/html-vs-html5/) 、CSS 和 JavaScript 来呈现页面的内容、样式和功能。

它们并不总是容易混合，因为:

*   相关代码可以在三个或更多文件之间拆分，并且
*   全局样式和 JavaScript 对象可能会以意想不到的方式相互干扰。

这些问题是除了语言运行时、[框架](https://kinsta.com/blog/javascript-libraries/)、数据库和服务器上使用的其他依赖项所遇到的问题之外的问题。

### 查看我们的[Web 组件视频指南](https://www.youtube.com/watch?v=hVxZ-te0kio)

## 什么是 Web 组件？

Web 组件是创建可在任何页面上重用的封装的单一责任代码块的一种方式。









考虑 HTML `**<video>**`标签。给定一个 [URL](https://kinsta.com/knowledgebase/what-is-a-url/) ，观众可以使用播放、暂停、后退、前进和调节音量等控件。

提供了样式和功能，尽管您可以使用各种属性和 JavaScript API 调用进行修改。任何数量的`**<video>**`元素都可以放在其他标签中，它们不会冲突。

如果您需要自己的定制功能，该怎么办？比如显示页面字数的元素？还没有 HTML `**<wordcount>**`标签。

像 [React](https://kinsta.com/blog/javascript-libraries/#reactjs) 和 [Vue.js](https://kinsta.com/blog/vue-js/) 这样的框架允许开发者创建 web 组件，其中的内容、样式和功能可以在一个 JavaScript 文件中定义。这些解决了许多复杂的编程问题，但请记住:

*   您必须学习如何使用该框架，并随着它的发展更新您的代码。
*   为一个框架编写的组件很少与另一个框架兼容。
*   框架的受欢迎程度有升有降。你将变得依赖于开发团队和用户的突发奇想和优先权。
*   标准的 Web 组件可以添加浏览器功能，这是单靠 JavaScript 很难实现的(比如影子 DOM)。

幸运的是，库和框架中引入的流行概念通常会成为 web 标准。虽然花了一些时间，但 Web 组件已经到来。

## Web 组件的简史

在许多特定于供应商的错误开始之后，[亚历克斯·罗素在 2011 年](https://fronteers.nl/congres/2011/sessions/web-components-and-model-driven-views-alex-russell)的 Fronteers 会议上首次提出了标准 Web 组件的概念。两年后，谷歌的[聚合物库](https://github.com/Polymer/polymer)(基于当前提案的 polyfill)问世，但早期实现直到 2016 年才出现在 Chrome 和 Safari 中。

浏览器厂商花了时间协商细节，但 2018 年 Firefox 和 2020 年 Edge(微软改用 Chromium 引擎时)都添加了 Web 组件。

可以理解的是，很少有开发人员愿意或能够采用 Web 组件，但是我们最终通过稳定的 API 达到了良好的浏览器支持水平。并非一切都是完美的，但它们是基于框架的组件越来越可行的替代方案。

即使你现在还不愿意放弃你最喜欢的，Web 组件与所有的框架都是兼容的，而且这些 API 将在未来几年得到支持。

每个人都可以查看预构建 Web 组件的存储库:

*   [WebComponents.org](https://www.webcomponents.org/)
*   [组件库](https://component.gallery/)
*   [通用组件](https://genericcomponents.netlify.app/)
*   [网络组件示例](https://github.com/mdn/web-components-examples)
*   [太棒了——单机版](https://github.com/davatron5000/awesome-standalones)
*   [可访问 _ 组件](https://github.com/scottaohara/accessible_components)
*   [Kickstand 用户界面](https://kickstand-ui.com/)

…但是编写自己的代码更有趣！

本教程全面介绍了不用 JavaScript 框架编写的 Web 组件。您将了解它们是什么，以及如何将它们应用到您的 web 项目中。你需要一些关于 HTML5、CSS 和 JavaScript 的知识。

## Web 组件入门

Web 组件是定制的 HTML 元素，比如`**<hello-world></hello-world>**`。名称必须包含破折号，以免与 HTML 规范中正式支持的元素冲突。

您必须定义一个 ES2015 类来控制元素。它可以被命名为任何名称，但 HelloWorld 是常见的做法。它必须扩展 [HTMLElement 接口](https://developer.mozilla.org/docs/Web/API/HTMLElement)，该接口代表每个 HTML 元素的默认属性和方法。

**注意:** [Firefox](https://kinsta.com/blog/most-secure-browser/#3-firefox) 允许你扩展特定的 HTML 元素，比如 HTMLParagraphElement、HTMLImageElement 或者 HTMLButtonElement。这在其他浏览器中不受支持，并且不允许您创建影子 DOM。

要做任何有用的事情，该类需要一个名为 **connectedCallback()** 的方法，当元素被添加到文档中时会调用该方法:

```
class HelloWorld extends HTMLElement {

  // connect component
  connectedCallback() {
    this.textContent = 'Hello World!';
  }

} 
```

在这个例子中，元素的文本被设置为“Hello World”

该类必须向 [CustomElementRegistry](https://developer.mozilla.org/docs/Web/API/CustomElementRegistry) 注册，以将其定义为特定元素的处理程序:

```
customElements.define( 'hello-world', HelloWorld ); 
```

现在，当您的 JavaScript 被加载时，浏览器会将`**<hello-world>**`元素与您的 **HelloWorld** 类相关联(例如`**<script type="module" src="./helloworld.js"></script>**`)。

您现在有了一个自定义元素！

<iframe class="wp-embedded-content" sandbox="allow-scripts" security="restricted" title="<hello-world> component" src="https://codepen.io/craigbuckler/embed/preview/WNpaxPN?default-tabs=js%2Cresult&amp;height=300&amp;host=https%3A%2F%2Fcodepen.io&amp;slug-hash=WNpaxPN#?secret=1qOrTEtWbL" data-secret="1qOrTEtWbL" scrolling="no" frameborder="0" height="300"></p> <p><a href="https://codepen.io/craigbuckler/pen/WNpaxPN"> CodePen 演示</a></p> <p>该组件可以像任何其他元素一样在 CSS 中设置样式:</p> <pre><code class="language-css">hello-world {&#13; font-weight: bold;&#13; color: red;&#13; }&#13; </code></pre>  <h3>添加属性</h3> <p>这个组件没有什么好处，因为无论如何都会输出相同的文本。像任何其他元素一样，我们可以添加 HTML 属性:</p> <pre><code class="language-html">&lt;hello-world name="Craig"&gt;&lt;/hello-world&gt;&#13; </code></pre> <p>这可能会覆盖文本，因此“你好克雷格！”已显示。为了实现这一点，您可以向<b> HelloWorld </b>类添加一个<b>构造函数()</b>，该函数在创建每个对象时运行。它必须:</p> <ol> <li>调用<b> super() </b>方法初始化父 HTMLElement，并</li> <li>进行其他初始化。在这种情况下，我们将定义一个默认设置为“World”的<b> name </b>属性:</li> </ol> <pre><code class="language-js">class HelloWorld extends HTMLElement {&#13; &#13; constructor() {&#13; super();&#13; this.name = 'World';&#13; }&#13; &#13; // more code...&#13; </code></pre> <p>您的组件只关心<b>名称</b>属性。静态<b> observedAttributes() </b>属性应该返回要观察的属性数组:</p> <pre><code class="language-js">// component attributes&#13; static get observedAttributes() {&#13; return ['name'];&#13; }&#13; </code></pre> <p>在 HTML 中定义属性或使用 JavaScript 更改属性时，会调用一个<b>attributeChangedCallback()</b>方法。它传递了属性名、旧值和新值:</p> <pre><code class="language-js">// attribute change&#13; attributeChangedCallback(property, oldValue, newValue) {&#13; &#13; if (oldValue === newValue) return;&#13; this[ property ] = newValue;&#13; &#13; }&#13; </code></pre> <p>在这个例子中，只有<b> name </b>属性会被更新，但是您可以根据需要添加额外的属性。</p> <p>最后，您需要调整<b> connectedCallback() </b>方法中的消息:</p> <pre><code class="language-js">// connect component&#13; connectedCallback() {&#13; &#13; this.textContent = `Hello ${ this.name }!`;&#13; &#13; }&#13; </code></pre> <p><a href="https://codepen.io/craigbuckler/pen/BaWqLOK"> CodePen 演示</a></p> <h3>生命周期方法</h3> <p>在 Web 组件状态的整个生命周期中，浏览器会自动调用六种方法。这里提供了完整的列表，尽管您已经在上面的示例中看到了前四个:</p> <h4>构造函数()</h4> <p>当组件第一次初始化时调用它。它必须调用<b> super() </b>，并可以设置任何默认值或执行其他预渲染过程。</p> <h4>静态观察属性()</h4> <p>返回浏览器将观察的属性数组。</p> <h4>attributeChangedCallback(propertyName, <b> oldValue, newValue) </b></h4> <p>每当观察到的属性改变时调用。那些在 HTML 中定义的会被立即传递，但是 JavaScript 可以修改它们:</p> <pre><code class="language-js">document.querySelector('hello-world').setAttribute('name', 'Everyone');&#13; </code></pre> <p>发生这种情况时，该方法可能需要触发重新呈现。</p> <h4>connectedCallback()</h4> <p>当 Web 组件附加到文档对象模型时，将调用此函数。它应该运行任何需要的渲染。</p> <h4>disconnectedCallback()</h4> <p>当 Web 组件从文档对象模型中删除时，就会调用它。如果你需要清理，比如删除存储的状态或者中止 Ajax 请求，这可能是有用的。</p> <h4>已采用回调()</h4> <p>当一个 Web 组件从一个文档移动到另一个文档时，调用这个函数。你可能会发现它的用处，尽管我一直在努力想出任何案例！<br/> </p> <h2>Web 组件如何与其他元素交互</h2> <p>Web 组件提供了一些 JavaScript 框架中没有的独特功能。</p> <h3>影子王国</h3> <p>虽然我们在上面构建的 Web 组件可以工作，但它不能免受外界干扰，CSS 或 JavaScript 可以修改它。类似地，您为组件定义的样式可能会泄露出去并影响到其他组件。</p> <p>影子 DOM 通过将一个单独的 DOM 附加到 Web 组件来解决这个封装问题:</p> <pre><code class="language-js">const shadow = this.attachShadow({ mode: 'closed' });&#13; </code></pre> <p>该模式可以是:</p><div class="in-post-container"> <div class="dialog__content"> <h2 class="heading--large text--center color--white mb--30">注册订阅时事通讯</h2>  </div>  <div class="box box--noshadow has-gray-background-color newsletter-cta"> <div class="newsletter-cta__content"> <h3 class="heading" style="font-size: 2rem;">想知道我们是怎么让流量增长超过 1000%的吗？</h3> <p class="mt--10 mb--20">加入 20，000 多名获得我们每周时事通讯和内部消息的人的行列吧！</p> </div> <a href="#newsletter" data-dialog-src="#newsletter" class="button button--purple newsletter-cta__button"> Subscribe Now </a> </div> </div> <ol> <li><b>【open】</b>—外层页面的 JavaScript 可以访问影子 DOM(使用<a href="https://developer.mozilla.org/docs/Web/API/Element/shadowRoot"> Element.shadowRoot </a>)，或者</li> <li><b>“关闭”</b> —影子 DOM 只能在 Web 组件中访问。</li> </ol> <p>阴影 DOM 可以像任何其他 DOM 元素一样进行操作:</p> <pre><code class="language-js">connectedCallback() {&#13; &#13; const shadow = this.attachShadow({ mode: 'closed' });&#13; &#13; shadow.innerHTML = `&#13; &lt;style&gt;&#13; p {&#13; text-align: center;&#13; font-weight: normal;&#13; padding: 1em;&#13; margin: 0 0 2em 0;&#13; background-color: #eee;&#13; border: 1px solid #666;&#13; }&#13; &lt;/style&gt;&#13; &#13; &lt;p&gt;Hello ${ this.name }!&lt;/p&gt;`;&#13; &#13; }&#13; </code></pre> <p>该组件现在在一个<code><b>&lt;p&gt;</b></code>元素中呈现“Hello”文本并设置样式。它不能被组件外的 JavaScript 或 CSS 修改，尽管有些样式如<a href="https://kinsta.com/blog/html-fonts/">字体</a>和颜色是从页面继承的，因为它们没有被显式定义。</p> <p><a href="https://codepen.io/craigbuckler/pen/rNyqyJJ"> CodePen 演示</a></p> <p>此 Web 组件范围内的样式不能影响页面上的其他段落，甚至不能影响其他<code><b>&lt;hello-world&gt;</b></code>组件。</p> <p>请注意，CSS <code>:host</code>选择器可以从 Web 组件内部设计外部<code><b>&lt;hello-world&gt;</b></code>元素的样式:</p> <pre><code class="language-css">:host {&#13; transform: rotate(180deg);&#13; }&#13; </code></pre> <p>您还可以设置元素使用特定类时要应用的样式，例如<code><b>&lt;hello-world class="rotate90"&gt;</b></code>:</p> <pre><code class="language-css">:host(.rotate90) {&#13; transform: rotate(90deg);&#13; }&#13; </code></pre> <h3>HTML 模板</h3> <p>对于更复杂的 Web 组件来说，在脚本中定义 HTML 可能变得不切实际。模板允许您在页面中定义 Web 组件可以使用的 HTML 块。这有几个好处:</p> <ol> <li>您可以调整 HTML 代码，而不必重写 JavaScript 中的字符串。</li> <li>可以定制组件，而不必为每种类型创建单独的 JavaScript 类。</li> <li>在 HTML 中定义 HTML 更容易，而且在组件呈现之前，可以在服务器或客户机上修改它。</li> </ol> <p>模板是在一个<code><b>&lt;template&gt;</b></code>标签中定义的，分配一个 ID 很实用，这样就可以在组件类中引用它。本例分三段显示“你好”消息:</p> <pre><code class="language-html">&lt;template id="hello-world"&gt;&#13; &#13; &lt;style&gt;&#13; p {&#13; text-align: center;&#13; font-weight: normal;&#13; padding: 0.5em;&#13; margin: 1px 0;&#13; background-color: #eee;&#13; border: 1px solid #666;&#13; }&#13; &lt;/style&gt;&#13; &#13; &lt;p class="hw-text"&gt;&lt;/p&gt;&#13; &lt;p class="hw-text"&gt;&lt;/p&gt;&#13; &lt;p class="hw-text"&gt;&lt;/p&gt;&#13; &#13; &lt;/template&gt;&#13; </code></pre> <p>Web 组件类可以访问这个模板，获取它的内容，并<a href="https://kinsta.com/knowledgebase/clone-wordpress-site/">克隆</a>这些元素，以确保在使用它的任何地方都创建一个唯一的 DOM 片段:</p> <pre><code class="language-js">const template = document.getElementById('hello-world').content.cloneNode(true);</code></pre> <p>DOM 可以被修改并直接添加到影子 DOM:</p> <pre><code class="language-js">connectedCallback() {&#13; &#13; const&#13; &#13; shadow = this.attachShadow({ mode: 'closed' }),&#13; template = document.getElementById('hello-world').content.cloneNode(true),&#13; hwMsg = `Hello ${ this.name }`;&#13; &#13; Array.from( template.querySelectorAll('.hw-text') )&#13; .forEach( n =&gt; n.textContent = hwMsg );&#13; &#13; shadow.append( template );&#13; &#13; }&#13; </code></pre> <p><a href="https://codepen.io/craigbuckler/pen/QWpZvdQ"> CodePen 演示</a></p> <h3>模板插槽</h3> <p>插槽允许您自定义模板。假设您想要使用您的<code><b>&lt;hello-world&gt;</b></code> Web 组件，但是将消息放在影子 DOM 中的<b>&lt;&gt;</b>标题内。您可以编写以下代码:</p> <pre><code class="language-html">&lt;hello-world name="Craig"&gt;&#13; &#13; &lt;h1 slot="msgtext"&gt;Hello Default!&lt;/h1&gt;&#13; &#13; &lt;/hello-world&gt;&#13; </code></pre> <p>(注意<b>槽</b>属性。)</p> <p>您可以选择添加其他元素，如另一个段落:</p> <pre><code class="language-html">&lt;hello-world name="Craig"&gt;&#13; &#13; &lt;h1 slot="msgtext"&gt;Hello Default!&lt;/h1&gt;&#13; &lt;p&gt;This text will become part of the component.&lt;/p&gt;&#13; &#13; &lt;/hello-world&gt;&#13; </code></pre> <p>插槽现在可以在您的模板中实现:</p> <div class="in-post-container"> <div id="simple-promo"> <div class="mb--20 mt--0 heading--normal"> <p>需要一个给你带来竞争优势的托管解决方案吗？Kinsta 为您提供了令人难以置信的速度、一流的安全性和自动伸缩功能。<a onclick="gtag('event', 'click', {'event_category': 'blog-article', 'event_label': 'blog-inarticle-minimaltext'})" href="https://kinsta.com/plans/?in-article-cta">查看我们的计划</a></p> </div> </div> </div> <pre><code class="language-html">&lt;template id="hello-world"&gt;&#13; &#13; &lt;slot name="msgtext" class="hw-text"&gt;&lt;/slot&gt;&#13; &#13; &lt;slot&gt;&lt;/slot&gt;&#13; &#13; &lt;/template&gt;&#13; </code></pre> <p>设置为“msgtext”(<code><b>&lt;h1&gt;</b></code>)的元素槽属性被插入到名为“msgtext”的<code><b>&lt;slot&gt;</b></code>处没有为<code><b>&lt;p&gt;</b></code>分配插槽名称，但是它被用于下一个可用的未命名的<code><b>&lt;slot&gt;</b></code>。实际上，模板变成了:</p> <pre><code class="language-html">&lt;template id="hello-world"&gt;&#13; &#13; &lt;slot name="msgtext" class="hw-text"&gt;&#13; &lt;h1 slot="msgtext"&gt;Hello Default!&lt;/h1&gt;&#13; &lt;/slot&gt;&#13; &#13; &lt;slot&gt;&#13; &lt;p&gt;This text will become part of the component.&lt;/p&gt;&#13; &lt;/slot&gt;&#13; &#13; &lt;/template&gt;&#13; </code></pre> <p>现实中没这么简单。阴影 DOM <i>中的一个<code><b>&lt;slot&gt;</b></code>元素将</i>指向插入的元素。您只能通过定位一个<code><b>&lt;slot&gt;</b></code>然后使用<a href="https://developer.mozilla.org/docs/Web/API/HTMLSlotElement/assignedNodes">来访问它们。assignedNodes()方法</a>返回内部子元素的数组。更新后的<b> connectedCallback() </b>方法:</p> <pre><code class="language-js">connectedCallback() {&#13; &#13; const&#13; shadow = this.attachShadow({ mode: 'closed' }),&#13; hwMsg = `Hello ${ this.name }`;&#13; &#13; // append shadow DOM&#13; shadow.append(&#13; document.getElementById('hello-world').content.cloneNode(true)&#13; );&#13; &#13; // find all slots with a hw-text class&#13; Array.from( shadow.querySelectorAll('slot.hw-text') )&#13; &#13; // update first assignedNode in slot&#13; .forEach( n =&gt; n.assignedNodes()[0].textContent = hwMsg );&#13; &#13; }&#13; </code></pre> <p><a href="https://codepen.io/craigbuckler/pen/gOmBBvm"> CodePen 演示</a></p> <p>此外，您不能直接设置插入元素的样式，尽管您可以将 Web 组件中的特定插槽作为目标:</p> <pre><code class="language-html">&lt;template id="hello-world"&gt;&#13; &#13; &lt;style&gt;&#13; slot[name="msgtext"] { color: green; }&#13; &lt;/style&gt;&#13; &#13; &lt;slot name="msgtext" class="hw-text"&gt;&lt;/slot&gt;&#13; &lt;slot&gt;&lt;/slot&gt;&#13; &#13; &lt;/template&gt;&#13; </code></pre> <p>模板槽有点不寻常，但是一个好处是如果 JavaScript 无法运行，你的内容将会显示出来。此代码显示了一个默认的标题和段落，只有在 Web 组件类成功执行时才会被替换:</p> <pre><code class="language-html">&lt;hello-world name="Craig"&gt;&#13; &#13; &lt;h1 slot="msgtext"&gt;Hello Default!&lt;/h1&gt;&#13; &lt;p&gt;This text will become part of the component.&lt;/p&gt;&#13; &#13; &lt;/hello-world&gt;&#13; </code></pre> <p>因此，您可以实现某种形式的渐进增强——即使只是一条<i>“您需要 JavaScript”</i>消息！</p> <h3>声明性阴影 DOM</h3> <p>上面的例子使用 JavaScript 构建了一个影子 DOM。这仍然是唯一的选择，但是正在为 Chrome 开发一个实验性的声明性阴影 DOM。这允许服务器端呈现，并避免任何布局变化或无样式内容的闪烁。</p> <p>HTML 解析器检测到以下代码，它创建了一个与您在上一节中创建的相同的影子 DOM(您需要根据需要更新消息):</p> <pre><code class="language-html">&lt;hello-world name="Craig"&gt;&#13; &#13; &lt;template shadowroot="closed"&gt;&#13; &lt;slot name="msgtext" class="hw-text"&gt;&lt;/slot&gt;&#13; &lt;slot&gt;&lt;/slot&gt;&#13; &lt;/template&gt;&#13; &#13; &lt;h1 slot="msgtext"&gt;Hello Default!&lt;/h1&gt;&#13; &lt;p&gt;This text will become part of the component.&lt;/p&gt;&#13; &#13; &lt;/hello-world&gt;&#13; </code></pre> <p>该功能在任何浏览器中都不可用，也不能保证它能在 Firefox 或 Safari 上使用。您可以<a href="https://web.dev/declarative-shadow-dom/">找到更多关于声明性阴影 DOM </a>的信息，polyfill 很简单，但是要注意实现可能会改变。</p> <h3>阴影 DOM 事件</h3> <p>您的 Web 组件可以将事件附加到 Shadow DOM 中的任何元素，就像在 page DOM 中一样，例如侦听所有内部子级上的 click 事件:</p> <pre><code class="language-js">shadow.addEventListener('click', e =&gt; {&#13; &#13; // do something&#13; &#13; });&#13; </code></pre> <p>除非您<a href="https://developer.mozilla.org/docs/Web/API/Event/stopPropagation">停止传播</a>，否则事件将冒泡到页面 DOM 中，但事件将被重定向。因此，它似乎来自您的自定义元素，而不是其中的元素。</p> <h1>在其他框架中使用 Web 组件</h1> <p>您创建的任何 Web 组件都可以在所有的<a href="https://kinsta.com/blog/javascript-libraries/#the-most-popular-javascript-frameworks"> JavaScript 框架</a>中工作。他们都不知道也不关心 HTML 元素——您的<code><b>&lt;hello-world&gt;</b></code>组件将被视为与<code><b>&lt;div&gt;</b></code>相同，并被放入类将被激活的 DOM 中。</p> <p><a href="https://custom-elements-everywhere.com/">custom-elements-everywhere.com</a>提供了框架和 Web 组件注释的列表。大多数都是完全兼容的，尽管 React.js 有一些挑战。在 JSX 可以使用<code><b>&lt;hello-world&gt;</b></code>:</p> <pre><code class="language-js">import React from 'react';&#13; import ReactDOM from 'react-dom';&#13; import from './hello-world.js';&#13; &#13; function MyPage() {&#13; &#13; return (&#13; &lt;&gt;&#13; &lt;hello-world name="Craig"&gt;&lt;/hello-world&gt; &#13; &lt;/&gt;&#13; );&#13; &#13; }&#13; &#13; ReactDOM.render(&lt;MyPage /&gt;, document.getElementById('root'));&#13; </code></pre> <p>…但是:</p> <ul> <li>React 只能将原始数据类型传递给 HTML 属性(不是数组或对象)</li> <li>React 无法监听 Web 组件事件，因此您必须手动附加自己的处理程序。</li> </ul> <h2>Web 组件的批评和问题</h2> <p>Web 组件有了显著的改进，但是有些方面可能很难管理。</p> <h3>造型困难</h3> <p>对 Web 组件进行样式化带来了一些挑战，尤其是当您想要覆盖作用域样式时。有许多解决方案:</p> <ol> <li>避免使用阴影 DOM。您可以将内容直接添加到您的定制元素中，尽管其他 JavaScript 可能会无意或恶意地更改它。</li> <li><strong>使用<code>:host</code>类。</strong>正如我们在上面看到的，<a href="https://kinsta.com/blog/critical-rendering-path/#optimize-css">作用域 CSS </a>可以在一个类被应用到自定义元素时应用特定的样式。</li> <li><strong>检查 CSS 自定义属性(变量)。</strong>自定义属性级联到 Web 组件中，因此，如果您的元素使用<code><b>var(--my-color)</b></code>，您可以在外部容器(如<code><b>:root</b></code>)中设置<code><b>--my-color</b></code>，它将被使用。</li> <li><strong>利用阴影部分。</strong>新的<a href="https://developer.mozilla.org/docs/Web/CSS/::part">:【part()】选择器</a>可以样式化一个具有部件属性的内部组件，即<code><b>&lt;hello-world&gt;</b></code>组件内部的<code><b>&lt;h1 part="heading"&gt;</b></code>可以用选择器<code><b>hello-world::part(heading)</b></code>来样式化。</li> <li><strong>传入一串样式。</strong>您可以将它们作为属性传递给一个<code><b>&lt;style&gt;</b></code>块。</li> </ol> <p>没有一个是理想的，您需要仔细计划其他用户如何定制您的 Web 组件。</p> <h3>忽略的输入</h3> <p>影子 DOM 中的任何<code><b>&lt;input&gt;</b></code>、<code><b>&lt;textarea&gt;</b></code>或<code><b>&lt;select&gt;</b></code>字段在包含表单中不会自动关联。早期的 Web 组件采用者会在页面 DOM 中添加隐藏字段，或者使用<a href="https://developer.mozilla.org/docs/Web/API/FormData"> FormData 接口</a>来更新值。两者都不是特别实用，而且破坏了 Web 组件封装。</p> <p>新的 ElementInternals 接口允许 Web 组件<a href="https://kinsta.com/blog/wordpress-hooks/">挂钩到</a>表单，因此可以定义自定义值和有效性。它是在 Chrome 中实现的，但是一个<a href="https://www.npmjs.com/package/element-internals-polyfill"> polyfill 可用于其他浏览器</a>。</p> <p>为了演示，您将创建一个基本的<code><b>&lt;input-age name="your-age"&gt;&lt;/input-age&gt;</b></code>组件。该类必须有一个静态的<b>与</b>相关联的值设置为真，并且可选地，当外部表单相关联时，可以调用一个<b>与 formAssociatedCallback() </b>方法:</p> <pre><code class="language-js">// &lt;input-age&gt; web component&#13; class InputAge extends HTMLElement {&#13; &#13; static formAssociated = true;&#13; &#13; formAssociatedCallback(form) {&#13; console.log('form associated:', form.id);&#13; }&#13; </code></pre> <p>构造函数现在必须运行<b> attachInternals() </b>方法，该方法允许组件与表单和其他想要检查值或验证的<a href="https://kinsta.com/knowledgebase/what-is-javascript/"> JavaScript 代码</a>进行通信:</p> <pre><code class="language-js"> constructor() {&#13; &#13; super();&#13; this.internals = this.attachInternals();&#13; this.setValue('');&#13; &#13; }&#13; &#13; // set form value&#13; &#13; setValue(v) {&#13; &#13; this.value = v;&#13; &#13; this.internals.setFormValue(v);&#13; &#13; }&#13; </code></pre> <p>ElementInternal 的<b> setFormValue() </b>方法在此处为用空字符串初始化的父表单设置元素的值(也可以向其传递具有多个名称/值对的 FormData 对象)。其他属性和方法包括:</p> <ul> <li><b>表单</b>:父表单</li> <li><b>标签</b>:标签组件的元素数组</li> <li><a href="https://developer.mozilla.org/docs/Web/API/Constraint_validation">约束验证 API </a>选项，如 willValidate、checkValidity 和 validationMessage</li> </ul> <p>像以前一样，<b> connectedCallback() </b>方法创建一个影子<a href="https://kinsta.com/blog/critical-rendering-path/#the-dom"> DOM </a>，但是还必须监视字段的变化，因此可以运行<b> setFormValue() </b>:</p> <pre><code class="language-js"> connectedCallback() {&#13; &#13; const shadow = this.attachShadow({ mode: 'closed' });&#13; &#13; shadow.innerHTML = `&#13; &lt;style&gt;input { width: 4em; }&lt;/style&gt;&#13; &lt;input type="number" placeholder="age" min="18" max="120" /&gt;`;&#13; &#13; // monitor input values&#13; shadow.querySelector('input').addEventListener('input', e =&gt; {&#13; this.setValue(e.target.value);&#13; });&#13; &#13; }&#13; </code></pre> <p>现在，您可以使用此 Web 组件创建一个 HTML 表单，其作用方式与其他表单域类似:</p> <pre><code class="language-html">&lt;form id="myform"&gt;&#13; &#13; &lt;input type="text" name="your-name" placeholder="name" /&gt;&#13; &#13; &lt;input-age name="your-age"&gt;&lt;/input-age&gt;&#13; &#13; &lt;button&gt;submit&lt;/button&gt;&#13; &#13; &lt;/form&gt;&#13; </code></pre> <p>它可以工作，但是不可否认地感觉有点复杂。</p> <p>在<a href="https://codepen.io/craigbuckler/pen/JjWmxwo"> CodePen 演示</a>中查看它</p> <p>有关更多信息，请参考<a href="https://web.dev/more-capable-form-controls/" target="_blank" rel="noopener noreferrer">这篇关于更强大的表单控件的文章</a>。</p> <a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fbit.ly%2F2UQA8x8&amp;via=kinsta&amp;text=Want+to+better+understand+web+components+and+how+they+work%3F+%E2%9C%85+Click+to+dive+in+%E2%AC%87%EF%B8%8F&amp;hashtags=CSS%2CHTML" class="novashare-ctt novashare-ctt-cta-left" target="_blank" rel="nofollow noopener noreferrer"><span class="novashare-ctt-tweet">Want to better understand web components and how they work? ✅ Click to dive in ⬇️</span><span class="novashare-ctt-cta-container"><span class="novashare-ctt-cta"><span class="novashare-ctt-cta-text">Click to Tweet</span><span class="novashare-ctt-cta-icon"><svg role="img" viewbox="0 0 512 512"><path fill="currentColor" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg></span></span></span></a> <h2>摘要</h2> <p>当 JavaScript 框架的地位和能力都在增长的时候，Web 组件却很难获得认同和采用。如果你来自 React、<a href="https://kinsta.com/blog/javascript-libraries/#vuejs"> Vue.js </a>或<a href="https://kinsta.com/blog/php-vs-angular/#what-is-angular"> Angular </a>，Web 组件可能看起来复杂而笨拙，尤其是当你缺少数据绑定和状态管理等功能时。</p> <p>虽然还有一些问题需要解决，但是 Web 组件的未来是光明的。它们是框架无关的、轻量级的、快速的，并且可以实现单独用 JavaScript 不可能实现的功能。</p> <p>十年前，很少有人会处理一个没有 jQuery T1 的网站，但是浏览器供应商吸取了优秀的部分并增加了本地的替代品(比如 querySelector)。JavaScript 框架也会出现同样的情况，而 Web 组件是试验性的第一步。</p> <p>关于如何使用 Web 组件，您有什么问题吗？在评论区说说吧！</p> <div class="user-content mt--40 pb--60"> <hr class="mini-divider"/> <p>让你所有的<a data-track-ga-category="single-post" data-track-ga-label="bottom-cta" href="https://kinsta.com/application-hosting/">应用程序</a>、<a data-track-ga-category="single-post" data-track-ga-label="bottom-cta" href="https://kinsta.com/database-hosting/">数据库</a>和<a data-track-ga-category="single-post" data-track-ga-label="bottom-cta" href="https://kinsta.com/wordpress-hosting/"> WordPress 网站</a>在线并在一个屋檐下。我们功能丰富的高性能云平台包括:</p> <ul> <li>在 MyKinsta 仪表盘中轻松设置和管理</li> <li>24/7 专家支持</li> <li>最好的谷歌云平台硬件和网络，由 Kubernetes 提供最大的可扩展性</li> <li>面向速度和安全性的企业级 Cloudflare 集成</li> <li>全球受众覆盖全球多达 35 个数据中心和 275 多个 pop</li> </ul> <p>在第一个月使用托管的<a data-track-ga-category="single-post" data-track-ga-label="bottom-cta" href="https://kinsta.com/application-hosting/">应用程序或托管</a>的<a data-track-ga-category="single-post" data-track-ga-label="bottom-cta" href="https://kinsta.com/database-hosting/">数据库，您可以享受 20 美元的优惠，亲自测试一下。探索我们的</a><a data-track-ga-category="single-post" data-track-ga-label="bottom-cta" href="https://kinsta.com/plans/">计划</a>或<a data-track-ga-category="single-post" data-track-ga-label="bottom-cta" href="https://kinsta.com/contact-us/">与销售人员交谈</a>以找到最适合您的方式。</p> </div> </body> </html></iframe>